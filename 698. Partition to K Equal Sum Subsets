class Solution {
    public boolean canPartitionKSubsets(int[] nums, int k) {
        
        int N  = nums.length;
        // If K is 1, then complete array will be our answer 
    if (k == 1)  return true; 
  
    // If total number of partitions are more than N, then 
    // division is not possible 
    if (N < k)  return false; 
  
    // if array sum is not divisible by K then we can't divide 
    // array into K partitions 
    int sum = 0; 
    for (int i = 0; i < N; i++) 
        sum += nums[i]; 
        
    if (sum % k != 0) return false; 
  
    // the sum of each subset should be subset (= sum / K) 
    int subset = sum / k; 
    int []subsetSum = new int[k]; 
    boolean []taken = new boolean[N]; 
  
    // Initialize sum of each subset from 0 
    for (int i = 0; i < k; i++) 
        subsetSum[i] = 0; 
  
    // mark all elements as not taken 
    for (int i = 0; i < N; i++) 
        taken[i] = false; 
  
    // initialize first subsubset sum as last element of 
    // array and mark that as taken 
    subsetSum[0] = nums[N - 1]; 
    taken[N - 1] = true; 
  
    // call recursive method to check K-substitution condition 
    return isKPartitionPossibleRec(nums, subsetSum, taken, 
                                    subset, k, N, 0, N - 1); 
        
    }
    
    static boolean isKPartitionPossibleRec(int arr[], int subsetSum[], boolean taken[], 
                int subset, int K, int N, int curIdx, int limitIdx) 
{ 
    if (subsetSum[curIdx] == subset) 
    { 
        /* current index (K - 2) represents (K - 1) subsets of equal 
            sum last partition will already remain with sum 'subset'*/
        if (curIdx == K - 2) 
            return true; 
  
        // recursive call for next subsetition 
        return isKPartitionPossibleRec(arr, subsetSum, taken, subset, 
                                            K, N, curIdx + 1, N - 1); 
    } 
  
    // start from limitIdx and include elements into current partition 
    for (int i = limitIdx; i >= 0; i--) 
    { 
        // if already taken, continue 
        if (taken[i]) 
            continue; 
        int tmp = subsetSum[curIdx] + arr[i]; 
  
        // if temp is less than subset then only include the element 
        // and call recursively 
        if (tmp <= subset) 
        { 
            // mark the element and include into current partition sum 
            taken[i] = true; 
            subsetSum[curIdx] += arr[i]; 
            boolean nxt = isKPartitionPossibleRec(arr, subsetSum, taken, 
                                            subset, K, N, curIdx, i - 1); 
  
            // after recursive call unmark the element and remove from 
            // subsetition sum 
            taken[i] = false; 
            subsetSum[curIdx] -= arr[i]; 
            if (nxt) 
                return true; 
        } 
    } 
    return false; 
} 
}
